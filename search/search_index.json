{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lounge \u00b6 Lounge is an Android library for building Leanback user interface required by Android TV. Installation \u00b6 Add dependencies to module build.gradle : dependencies { // Leanckback helper for ObjectAdapter, Presenter, GuidedAction and et al. implementation(\"jp.co.cyberagent.lounge:lounge:$latestVersion\") // Paging Support: implementation(\"jp.co.cyberagent.lounge:lounge-paging:$latestVersion\") // DataBinding Support: implementation(\"jp.co.cyberagent.lounge:lounge-databinding:$latestVersion\") // Navigation Component Support: implementation(\"jp.co.cyberagent.lounge:lounge-navigation:$latestVersion\") // Material Design Support: implementation(\"jp.co.cyberagent.lounge:lounge-material:$latestVersion\") } Documentation \u00b6 Check out Lounge\u2019s full documentation here . Contributing \u00b6 Feel free to open a issue or submit a pull request for any bugs/improvements.","title":"Overview"},{"location":"#lounge","text":"Lounge is an Android library for building Leanback user interface required by Android TV.","title":"Lounge"},{"location":"#installation","text":"Add dependencies to module build.gradle : dependencies { // Leanckback helper for ObjectAdapter, Presenter, GuidedAction and et al. implementation(\"jp.co.cyberagent.lounge:lounge:$latestVersion\") // Paging Support: implementation(\"jp.co.cyberagent.lounge:lounge-paging:$latestVersion\") // DataBinding Support: implementation(\"jp.co.cyberagent.lounge:lounge-databinding:$latestVersion\") // Navigation Component Support: implementation(\"jp.co.cyberagent.lounge:lounge-navigation:$latestVersion\") // Material Design Support: implementation(\"jp.co.cyberagent.lounge:lounge-material:$latestVersion\") }","title":"Installation"},{"location":"#documentation","text":"Check out Lounge\u2019s full documentation here .","title":"Documentation"},{"location":"#contributing","text":"Feel free to open a issue or submit a pull request for any bugs/improvements.","title":"Contributing"},{"location":"changelog/","text":"Changelog \u00b6 1.2.0 \u00b6 Change: targetVersion/compileVersion update to 31 Change: AGP is updated to 7.1.1 Change: MDC is update to 1.5.0 1.1.2 \u00b6 Fix: Deadlock in PagedListModelCache Change: Provide correct coroutine scope for PagedListModelCache 1.1.1 \u00b6 Fix: Fix JobCancellationException cased by sending element to closed channel 1.1.0 \u00b6 Change: Remove workerDispatcher from PagedListLoungeController constructor Fix: Fix internal IndexOutOfBoundsException in PagedListModelCache 1.0.0 \u00b6 First release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#120","text":"Change: targetVersion/compileVersion update to 31 Change: AGP is updated to 7.1.1 Change: MDC is update to 1.5.0","title":"1.2.0"},{"location":"changelog/#112","text":"Fix: Deadlock in PagedListModelCache Change: Provide correct coroutine scope for PagedListModelCache","title":"1.1.2"},{"location":"changelog/#111","text":"Fix: Fix JobCancellationException cased by sending element to closed channel","title":"1.1.1"},{"location":"changelog/#110","text":"Change: Remove workerDispatcher from PagedListLoungeController constructor Fix: Fix internal IndexOutOfBoundsException in PagedListModelCache","title":"1.1.0"},{"location":"changelog/#100","text":"First release","title":"1.0.0"},{"location":"guided-step/","text":"GuidedStep Support \u00b6 GuidedStepSupportFragment is used to represent a single step in a series of steps. Lounge provides some helper methods/classes to simplify creating GuidedStepSupportFragment . Create guided actions \u00b6 We can override onCreateActions() to add user actions. Lounge provides a DSL createGuidedActions(Context) to build multiple actions. override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { guidedAction { // You can access all methods defined in `GuidedAction.Builder` title ( \"Next\" ) } guidedAction { title ( \"Back\" ) description ( \"Really?\" ) } } } Set Event Listener \u00b6 When using the GuidedAction.Builder , we cannot directly define the event listener, like click listener, for an action. We need to override onGuidedActionClicked() and process via identify the passed-in GuidedAction . Use guidedAction {} DSL and other helper methods like onLoungeGuidedActionClicked together, set event listener can become easier. override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { guidedAction { title ( \"Hi\" ) onClicked { showToast ( \"Hello World!\" ) } } } } override fun onGuidedActionClicked ( action : GuidedAction?) { onLoungeGuidedActionClicked ( action ) } Add SubActions \u00b6 You can add sub actions via subActions {} . createGuidedActions ( requireContext ()) { guidedAction { title ( \"Sign Out\" ) subActions { guidedAction { title ( \"Yes\" ) } guidedAction { title ( \"No\" ) } } } } Custom Action Layout \u00b6 By override onCreateActionsStylist() and returns a LoungeGuidedActionsStylist , your layout file passed via layoutId(Int) can be correctly inflated. override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { guidedAction { infoOnly ( true ) focusable ( false ) layoutId ( R . layout . layout_divider ) } } } override fun onCreateActionsStylist (): GuidedActionsStylist { return LoungeGuidedActionsStylist () } LoungeGuidedStepSupportFragment \u00b6 If you want to reduce more boilerplate codes, you can extend the LoungeGuidedStepSupportFragment . LoungeGuidedStepSupportFragment already properly override methods that createGuidedActions(Context) DSL required. class GuidedStepExampleFragment : LoungeGuidedStepSupportFragment () { override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { } } Create Guidance \u00b6 We can override onCreateGuidance() and return a new GuidanceStylist.Guidance that contains context information, such as the step title, description, and icon. Lounge provides a top-level function Guidance for creating GuidanceStylist.Guidance . All parameters of Guidance are default null. override fun onCreateGuidance ( savedInstanceState : Bundle?) : GuidanceStylist . Guidance { return Guidance ( title = \"Title\" , description = \"Description\" ) } Navigation \u00b6 When using GuidedStepSupportFragment with Navigation Component, we need to manually setUiStyle to get correct transition animation. Lounge provides a GuidedStepFragmentNavigator to automatically do setUiStyle based on the back stack. See TODO for more details.","title":"GuidedStep Support"},{"location":"guided-step/#guidedstep-support","text":"GuidedStepSupportFragment is used to represent a single step in a series of steps. Lounge provides some helper methods/classes to simplify creating GuidedStepSupportFragment .","title":"GuidedStep Support"},{"location":"guided-step/#create-guided-actions","text":"We can override onCreateActions() to add user actions. Lounge provides a DSL createGuidedActions(Context) to build multiple actions. override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { guidedAction { // You can access all methods defined in `GuidedAction.Builder` title ( \"Next\" ) } guidedAction { title ( \"Back\" ) description ( \"Really?\" ) } } }","title":"Create guided actions"},{"location":"guided-step/#set-event-listener","text":"When using the GuidedAction.Builder , we cannot directly define the event listener, like click listener, for an action. We need to override onGuidedActionClicked() and process via identify the passed-in GuidedAction . Use guidedAction {} DSL and other helper methods like onLoungeGuidedActionClicked together, set event listener can become easier. override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { guidedAction { title ( \"Hi\" ) onClicked { showToast ( \"Hello World!\" ) } } } } override fun onGuidedActionClicked ( action : GuidedAction?) { onLoungeGuidedActionClicked ( action ) }","title":"Set Event Listener"},{"location":"guided-step/#add-subactions","text":"You can add sub actions via subActions {} . createGuidedActions ( requireContext ()) { guidedAction { title ( \"Sign Out\" ) subActions { guidedAction { title ( \"Yes\" ) } guidedAction { title ( \"No\" ) } } } }","title":"Add SubActions"},{"location":"guided-step/#custom-action-layout","text":"By override onCreateActionsStylist() and returns a LoungeGuidedActionsStylist , your layout file passed via layoutId(Int) can be correctly inflated. override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { guidedAction { infoOnly ( true ) focusable ( false ) layoutId ( R . layout . layout_divider ) } } } override fun onCreateActionsStylist (): GuidedActionsStylist { return LoungeGuidedActionsStylist () }","title":"Custom Action Layout"},{"location":"guided-step/#loungeguidedstepsupportfragment","text":"If you want to reduce more boilerplate codes, you can extend the LoungeGuidedStepSupportFragment . LoungeGuidedStepSupportFragment already properly override methods that createGuidedActions(Context) DSL required. class GuidedStepExampleFragment : LoungeGuidedStepSupportFragment () { override fun onCreateActions ( actions : MutableList < GuidedAction > , savedInstanceState : Bundle?) { actions += createGuidedActions ( requireContext ()) { } }","title":"LoungeGuidedStepSupportFragment"},{"location":"guided-step/#create-guidance","text":"We can override onCreateGuidance() and return a new GuidanceStylist.Guidance that contains context information, such as the step title, description, and icon. Lounge provides a top-level function Guidance for creating GuidanceStylist.Guidance . All parameters of Guidance are default null. override fun onCreateGuidance ( savedInstanceState : Bundle?) : GuidanceStylist . Guidance { return Guidance ( title = \"Title\" , description = \"Description\" ) }","title":"Create Guidance"},{"location":"guided-step/#navigation","text":"When using GuidedStepSupportFragment with Navigation Component, we need to manually setUiStyle to get correct transition animation. Lounge provides a GuidedStepFragmentNavigator to automatically do setUiStyle based on the back stack. See TODO for more details.","title":"Navigation"},{"location":"material/","text":"MaterialDesign Support \u00b6 Lounge provides Theme.MaterialComponents.Leanback.Bridge , a theme contains style attributes both required by Leanback and MaterialComponents. Usage \u00b6 Installation \u00b6 dependencies { implementation 'jp.co.cyberagent.lounge:lounge-material:$latestVersion' } Ensure you are using AppCompatActivity \u00b6 class TvActivity : AppCompatActivity () { // Set up } Change your app theme \u00b6 In your theme xml files: <style name= \"Theme.MyApp\" parent= \"Theme.MaterialComponents.Leanback.Bridge\" > <!-- ... --> </style> In your AndroidManifest.xml : <application android:label= \"@string/app_name\" android:theme= \"@style/AppTheme\" > <activity android:name= \".TvActivity\" /> </Applications> Now your can use MaterialComponents in your application.","title":"MaterialDesign Support"},{"location":"material/#materialdesign-support","text":"Lounge provides Theme.MaterialComponents.Leanback.Bridge , a theme contains style attributes both required by Leanback and MaterialComponents.","title":"MaterialDesign Support"},{"location":"material/#usage","text":"","title":"Usage"},{"location":"material/#installation","text":"dependencies { implementation 'jp.co.cyberagent.lounge:lounge-material:$latestVersion' }","title":"Installation"},{"location":"material/#ensure-you-are-using-appcompatactivity","text":"class TvActivity : AppCompatActivity () { // Set up }","title":"Ensure you are using AppCompatActivity"},{"location":"material/#change-your-app-theme","text":"In your theme xml files: <style name= \"Theme.MyApp\" parent= \"Theme.MaterialComponents.Leanback.Bridge\" > <!-- ... --> </style> In your AndroidManifest.xml : <application android:label= \"@string/app_name\" android:theme= \"@style/AppTheme\" > <activity android:name= \".TvActivity\" /> </Applications> Now your can use MaterialComponents in your application.","title":"Change your app theme"},{"location":"object-adapter/","text":"ObjectAdapter Support \u00b6 ObjectAdapter is used in many Leanback components (e.g. BrowseSupportFragment , VerticalGridSupportFragment , et al.) to display list items. ObjectAdapter uses Presenter s to create views and bind data to those views. Lounge provides LoungeController and LoungeModel to help you construct ObjectAdapter in a declarative programming style. The implementation of LoungeController is referred to the well-known RecyclerView library Airbnb/Epoxy . If you are familiar with Epoxy, Lounge will be easy to use. Basic Usage \u00b6 Described here are the fundamentals for building list UIs with Lounge. Creating LoungeModel \u00b6 LoungeModel is the base unit that describe how your views should be displayed via the Presenter . data class TextModel ( val name : String ) : LoungeModel { override val key : Long = name . toLoungeModelKey () override val presenter : Presenter = TextModelPresenter } Each LoungeModel should have a unique key to allow RecyclerView diffing algorithm works. You can use the extension function Any.toLoungeModelKey() to get a key from any object. To get better performance, it is recommended to also implement equals() properly. In Kotlin, we can easily achieve this via data class. The presenter is a normal Leanback Presenter which can bind the LoungeModel to a view. You can create Presenter using the default ViewHolder pattern that provided by Leanback itself or using the DataBindingPresenter provided by Lounge. Presenter better be a singleton object so it can be shared with multiple instances. DataBindingPresenter example: object TextModelPresenter : DataBindingPresenter < TextModel , ModelTextBinding > ( R . layout . model_text ) { override fun onBind ( binding : ModelTextBinding , item : TextModel ) { binding . model = item } } Or simply using SimpleDataBindingPresenter : data class TextModel ( val name : String , ) : LoungeModel { override val key : Long = name . toLoungeModelKey () override val presenter : Presenter get () = SimpleDataBindingPresenter < TextModel > ( R . layout . model_text , BR . model ) } Using LoungeModel inside LoungeController \u00b6 LoungeController defines what LoungeModel s should be added into the ObjectAdapter . The controller\u2019s buildModels method declared which LoungeModel s to show. You are responsible for calling requestModelBuild whenever your data changes, which triggers buildModels to run again. Example to show a list of TextModel : class MyController ( lifecycle : Lifecycle ) : LoungeController ( lifecycle ) { var names : List < String > = emptyList () set ( value ) { if ( field != value ) { field = value requestModelBuild () } } override suspend fun buildModels () { names . forEach { + TextModel ( it ) } } } Every time names changes, we call requestModelBuild . The custom getter of names contains a lot of boilerplate code, instead we can use the loungeProp delegated property: var names : List < String > by loungeProp ( emptyList ()) Similar to Epoxy, requestModelBuild requests that models be built but does not guarantee that it will happen immediately. Calling requestModelBuild multiple times will cancel the previous uncompleted build. This is to decouple model building from data changes. This way all data updates can be completed in full without worrying about calling requestModelBuild multiple times. Integrating with Leanback components \u00b6 We can get the backing ObjectAdapter off the LoungeController and set up into Leanback components. Here are some examples. Set up for VerticalGridSupportFragment \u00b6 class MyVerticalGripFragment : VerticalGridSupportFragment () { private val viewModel by viewModels < MyViewModel > () private val controller by lazy { MyController ( lifecycle ) } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) gridPresenter = VerticalGridPresenter (). apply { numberOfColumns = 5 } adapter = controller . adapter } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) viewModel . names . observe ( viewLifecycleOwner ) { controller . names = it } } } Set up for RowsSupportFragment \u00b6 Lounge provides listRow , listRowFor , listRowOf for simplify creating multiple rows UI. Create a LoungeController that has two rows, await all data becoming available before the first build: class MyRowsController ( lifecycle : Lifecycle ) : LoungeController ( lifecycle ) { var row1 : List < String >? by loungeProp ( null ) var row2 : List < String >? by loungeProp ( null ) override suspend fun buildModels () { val row1 = row1 ?: awaitCancellation () val row2 = row2 ?: awaitCancellation () listRowFor ( name = \"Row 1\" , list = row1 ) { TextModel ( it ) } listRowFor ( name = \"Row 2\" , list = row2 ) { TextModel ( it ) } } } Use the controller inside BrowseSupportFragment : class MyRowsFragment : RowsSupportFragment () { private val controller by lazy { MyRowsController ( lifecycle ) } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) adapter = controller . adapter } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // Observe data and update row1, row2 } } Advanced Usage \u00b6 // TODO","title":"ObjectAdapter Support"},{"location":"object-adapter/#objectadapter-support","text":"ObjectAdapter is used in many Leanback components (e.g. BrowseSupportFragment , VerticalGridSupportFragment , et al.) to display list items. ObjectAdapter uses Presenter s to create views and bind data to those views. Lounge provides LoungeController and LoungeModel to help you construct ObjectAdapter in a declarative programming style. The implementation of LoungeController is referred to the well-known RecyclerView library Airbnb/Epoxy . If you are familiar with Epoxy, Lounge will be easy to use.","title":"ObjectAdapter Support"},{"location":"object-adapter/#basic-usage","text":"Described here are the fundamentals for building list UIs with Lounge.","title":"Basic Usage"},{"location":"object-adapter/#creating-loungemodel","text":"LoungeModel is the base unit that describe how your views should be displayed via the Presenter . data class TextModel ( val name : String ) : LoungeModel { override val key : Long = name . toLoungeModelKey () override val presenter : Presenter = TextModelPresenter } Each LoungeModel should have a unique key to allow RecyclerView diffing algorithm works. You can use the extension function Any.toLoungeModelKey() to get a key from any object. To get better performance, it is recommended to also implement equals() properly. In Kotlin, we can easily achieve this via data class. The presenter is a normal Leanback Presenter which can bind the LoungeModel to a view. You can create Presenter using the default ViewHolder pattern that provided by Leanback itself or using the DataBindingPresenter provided by Lounge. Presenter better be a singleton object so it can be shared with multiple instances. DataBindingPresenter example: object TextModelPresenter : DataBindingPresenter < TextModel , ModelTextBinding > ( R . layout . model_text ) { override fun onBind ( binding : ModelTextBinding , item : TextModel ) { binding . model = item } } Or simply using SimpleDataBindingPresenter : data class TextModel ( val name : String , ) : LoungeModel { override val key : Long = name . toLoungeModelKey () override val presenter : Presenter get () = SimpleDataBindingPresenter < TextModel > ( R . layout . model_text , BR . model ) }","title":"Creating LoungeModel"},{"location":"object-adapter/#using-loungemodel-inside-loungecontroller","text":"LoungeController defines what LoungeModel s should be added into the ObjectAdapter . The controller\u2019s buildModels method declared which LoungeModel s to show. You are responsible for calling requestModelBuild whenever your data changes, which triggers buildModels to run again. Example to show a list of TextModel : class MyController ( lifecycle : Lifecycle ) : LoungeController ( lifecycle ) { var names : List < String > = emptyList () set ( value ) { if ( field != value ) { field = value requestModelBuild () } } override suspend fun buildModels () { names . forEach { + TextModel ( it ) } } } Every time names changes, we call requestModelBuild . The custom getter of names contains a lot of boilerplate code, instead we can use the loungeProp delegated property: var names : List < String > by loungeProp ( emptyList ()) Similar to Epoxy, requestModelBuild requests that models be built but does not guarantee that it will happen immediately. Calling requestModelBuild multiple times will cancel the previous uncompleted build. This is to decouple model building from data changes. This way all data updates can be completed in full without worrying about calling requestModelBuild multiple times.","title":"Using LoungeModel inside LoungeController"},{"location":"object-adapter/#integrating-with-leanback-components","text":"We can get the backing ObjectAdapter off the LoungeController and set up into Leanback components. Here are some examples.","title":"Integrating with Leanback components"},{"location":"object-adapter/#set-up-for-verticalgridsupportfragment","text":"class MyVerticalGripFragment : VerticalGridSupportFragment () { private val viewModel by viewModels < MyViewModel > () private val controller by lazy { MyController ( lifecycle ) } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) gridPresenter = VerticalGridPresenter (). apply { numberOfColumns = 5 } adapter = controller . adapter } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) viewModel . names . observe ( viewLifecycleOwner ) { controller . names = it } } }","title":"Set up for VerticalGridSupportFragment"},{"location":"object-adapter/#set-up-for-rowssupportfragment","text":"Lounge provides listRow , listRowFor , listRowOf for simplify creating multiple rows UI. Create a LoungeController that has two rows, await all data becoming available before the first build: class MyRowsController ( lifecycle : Lifecycle ) : LoungeController ( lifecycle ) { var row1 : List < String >? by loungeProp ( null ) var row2 : List < String >? by loungeProp ( null ) override suspend fun buildModels () { val row1 = row1 ?: awaitCancellation () val row2 = row2 ?: awaitCancellation () listRowFor ( name = \"Row 1\" , list = row1 ) { TextModel ( it ) } listRowFor ( name = \"Row 2\" , list = row2 ) { TextModel ( it ) } } } Use the controller inside BrowseSupportFragment : class MyRowsFragment : RowsSupportFragment () { private val controller by lazy { MyRowsController ( lifecycle ) } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) adapter = controller . adapter } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // Observe data and update row1, row2 } }","title":"Set up for RowsSupportFragment"},{"location":"object-adapter/#advanced-usage","text":"// TODO","title":"Advanced Usage"},{"location":"wip/","text":"WIP \u00b6","title":"Navigation Support"},{"location":"wip/#wip","text":"","title":"WIP"}]}